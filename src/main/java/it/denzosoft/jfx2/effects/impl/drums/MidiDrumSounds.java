package it.denzosoft.jfx2.effects.impl.drums;

import it.denzosoft.jfx2.audio.SoundfontSettings;
import it.denzosoft.jfx2.effects.impl.drums.DrumSounds.DrumSound;

import javax.sound.midi.*;
import javax.sound.sampled.*;
import java.io.File;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

/**
 * Drum sounds generated by rendering MIDI through Java's Gervill synthesizer.
 *
 * <p>Uses the AudioSynthesizer interface (from Gervill) for offline rendering.
 * Supports loading external SF2/DLS soundfont files.</p>
 *
 * <p>Uses reflection to access com.sun.media.sound.AudioSynthesizer to avoid
 * IllegalAccessError when the module system restricts access.</p>
 */
public class MidiDrumSounds implements DrumSoundProvider {

    private final int sampleRate;
    private final Map<DrumSound, float[]> sounds = new HashMap<>();
    private String soundfontName = "Default";

    // General MIDI drum note numbers (channel 10, 0-indexed = 9)
    private static final int DRUM_CHANNEL = 9;

    private static final Map<DrumSound, Integer> NOTE_MAP = Map.ofEntries(
            Map.entry(DrumSound.KICK, 36),           // Bass Drum 1
            Map.entry(DrumSound.SNARE, 38),          // Acoustic Snare
            Map.entry(DrumSound.HIHAT_CLOSED, 42),   // Closed Hi-Hat
            Map.entry(DrumSound.HIHAT_OPEN, 46),     // Open Hi-Hat
            Map.entry(DrumSound.CRASH, 49),          // Crash Cymbal 1
            Map.entry(DrumSound.RIDE, 51),           // Ride Cymbal 1
            Map.entry(DrumSound.RIDE_BELL, 53),      // Ride Bell
            Map.entry(DrumSound.TOM_HIGH, 50),       // High Tom
            Map.entry(DrumSound.TOM_MID, 47),        // Low-Mid Tom
            Map.entry(DrumSound.TOM_LOW, 45),        // Low Tom
            Map.entry(DrumSound.RIMSHOT, 37),        // Side Stick
            Map.entry(DrumSound.CLAP, 39),           // Hand Clap
            Map.entry(DrumSound.COWBELL, 56),        // Cowbell
            Map.entry(DrumSound.STICKS, 31)          // Sticks
    );

    // Duration to render for each sound type (in seconds)
    private static final Map<DrumSound, Float> RENDER_DURATIONS = Map.ofEntries(
            Map.entry(DrumSound.KICK, 0.6f),
            Map.entry(DrumSound.SNARE, 0.5f),
            Map.entry(DrumSound.HIHAT_CLOSED, 0.2f),
            Map.entry(DrumSound.HIHAT_OPEN, 0.8f),
            Map.entry(DrumSound.CRASH, 3.0f),
            Map.entry(DrumSound.RIDE, 2.0f),
            Map.entry(DrumSound.RIDE_BELL, 1.2f),
            Map.entry(DrumSound.TOM_HIGH, 0.6f),
            Map.entry(DrumSound.TOM_MID, 0.7f),
            Map.entry(DrumSound.TOM_LOW, 0.8f),
            Map.entry(DrumSound.RIMSHOT, 0.3f),
            Map.entry(DrumSound.CLAP, 0.5f),
            Map.entry(DrumSound.COWBELL, 0.4f),
            Map.entry(DrumSound.STICKS, 0.15f)
    );

    // Cached reflection data
    private static final String AUDIO_SYNTH_CLASS = "com.sun.media.sound.AudioSynthesizer";
    private static Boolean audioSynthAvailable = null;

    public MidiDrumSounds(int sampleRate) {
        this.sampleRate = sampleRate;
        generateAllSounds();
    }

    private void generateAllSounds() {
        // Get soundfont settings
        SoundfontSettings settings = SoundfontSettings.getInstance();
        File sf2File = settings.isUseExternalSoundfont() ? settings.getSf2File() : null;

        try {
            // Get the synthesizer
            Synthesizer synth = MidiSystem.getSynthesizer();

            // Check if it's an AudioSynthesizer using reflection
            if (isAudioSynthesizer(synth)) {
                generateWithAudioSynthesizer(synth, sf2File);
            } else {
                createEmptySounds();
            }

        } catch (Exception e) {
            createEmptySounds();
        }
    }

    /**
     * Check if synth is an AudioSynthesizer using reflection.
     */
    private boolean isAudioSynthesizer(Synthesizer synth) {
        try {
            Class<?> audioSynthClass = Class.forName(AUDIO_SYNTH_CLASS);
            return audioSynthClass.isInstance(synth);
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Call openStream() on the AudioSynthesizer via reflection.
     */
    private AudioInputStream openAudioStream(Synthesizer synth, AudioFormat format) throws Exception {
        Class<?> audioSynthClass = Class.forName(AUDIO_SYNTH_CLASS);
        Method openStreamMethod = audioSynthClass.getMethod("openStream", AudioFormat.class, Map.class);
        return (AudioInputStream) openStreamMethod.invoke(synth, format, null);
    }

    private void generateWithAudioSynthesizer(Synthesizer synth, File sf2File) {
        try {
            // Define audio format for rendering
            AudioFormat format = new AudioFormat(sampleRate, 16, 1, true, false);

            // Open synthesizer with audio stream using reflection
            AudioInputStream audioStream = openAudioStream(synth, format);

            // Load soundfont if specified
            if (sf2File != null && sf2File.exists()) {
                try {
                    Soundbank soundbank = MidiSystem.getSoundbank(sf2File);
                    synth.loadAllInstruments(soundbank);
                    soundfontName = soundbank.getName();
                } catch (Exception e) {
                    soundfontName = "Default (SF2 load failed)";
                }
            } else {
                // Use default soundbank
                Soundbank defaultSoundbank = synth.getDefaultSoundbank();
                if (defaultSoundbank != null) {
                    synth.loadAllInstruments(defaultSoundbank);
                    soundfontName = "Default (" + defaultSoundbank.getName() + ")";
                } else {
                    soundfontName = "Default (built-in)";
                }
            }

            // Get drum channel
            MidiChannel drumChannel = synth.getChannels()[DRUM_CHANNEL];

            // Render each drum sound
            for (DrumSound sound : DrumSound.values()) {
                if (sound == DrumSound.REST) {
                    sounds.put(sound, new float[0]);
                    continue;
                }

                Integer noteNumber = NOTE_MAP.get(sound);
                float duration = RENDER_DURATIONS.getOrDefault(sound, 0.5f);

                if (noteNumber != null) {
                    float[] samples = renderNote(drumChannel, audioStream, noteNumber, duration);
                    if (samples != null && hasSignal(samples)) {
                        sounds.put(sound, normalize(trimSilence(samples)));
                    } else {
                        sounds.put(sound, new float[(int)(sampleRate * duration)]);
                    }
                }
            }

            // Close synthesizer
            audioStream.close();
            synth.close();

        } catch (Exception e) {
            createEmptySounds();
        }
    }

    private float[] renderNote(MidiChannel channel, AudioInputStream audioStream,
                               int noteNumber, float duration) {
        try {
            int numSamples = (int) (sampleRate * duration);
            int bytesPerSample = 2; // 16-bit
            byte[] audioData = new byte[numSamples * bytesPerSample];

            // Clear any residual sound
            channel.allNotesOff();
            channel.allSoundOff();

            // Read and discard any pending audio (silence)
            byte[] discard = new byte[1024];
            while (audioStream.available() > 0) {
                audioStream.read(discard);
            }

            // Trigger the note
            channel.noteOn(noteNumber, 100);

            // Read audio data
            int totalRead = 0;
            while (totalRead < audioData.length) {
                int toRead = Math.min(4096, audioData.length - totalRead);
                int read = audioStream.read(audioData, totalRead, toRead);
                if (read < 0) break;
                totalRead += read;
            }

            // Note off
            channel.noteOff(noteNumber);

            // Read a bit more for the release tail
            int tailSamples = sampleRate / 10; // 100ms tail
            byte[] tailData = new byte[tailSamples * bytesPerSample];
            audioStream.read(tailData);

            // Convert bytes to float samples
            float[] samples = new float[numSamples];
            for (int i = 0; i < numSamples; i++) {
                int lo = audioData[i * 2] & 0xFF;
                int hi = audioData[i * 2 + 1];
                short sample = (short) ((hi << 8) | lo);
                samples[i] = sample / 32768.0f;
            }

            return samples;

        } catch (Exception e) {
            return null;
        }
    }

    private void createEmptySounds() {
        for (DrumSound sound : DrumSound.values()) {
            float duration = RENDER_DURATIONS.getOrDefault(sound, 0.5f);
            sounds.put(sound, new float[(int)(sampleRate * duration)]);
        }
    }

    private boolean hasSignal(float[] samples) {
        float threshold = 0.001f;
        for (float s : samples) {
            if (Math.abs(s) > threshold) return true;
        }
        return false;
    }

    private float[] trimSilence(float[] samples) {
        // Find start (first sample above threshold)
        int start = 0;
        float threshold = 0.001f;
        for (int i = 0; i < samples.length; i++) {
            if (Math.abs(samples[i]) > threshold) {
                start = Math.max(0, i - 10); // Keep a few samples before
                break;
            }
        }

        // Find end (last sample above threshold)
        int end = samples.length;
        for (int i = samples.length - 1; i >= start; i--) {
            if (Math.abs(samples[i]) > threshold) {
                end = Math.min(samples.length, i + sampleRate / 20); // 50ms tail
                break;
            }
        }

        if (start >= end) {
            return samples; // No trimming needed
        }

        float[] trimmed = new float[end - start];
        System.arraycopy(samples, start, trimmed, 0, trimmed.length);
        return trimmed;
    }

    private float[] normalize(float[] samples) {
        float max = 0;
        for (float s : samples) {
            max = Math.max(max, Math.abs(s));
        }
        if (max > 0.001f) {
            float gain = 0.92f / max;
            for (int i = 0; i < samples.length; i++) {
                samples[i] *= gain;
            }
        }
        return samples;
    }

    // ==================== INTERFACE METHODS ====================

    @Override
    public float[] getSound(DrumSound sound) {
        return sounds.getOrDefault(sound, new float[0]);
    }

    @Override
    public int getSampleRate() {
        return sampleRate;
    }

    @Override
    public String getName() {
        return "MIDI: " + soundfontName;
    }

    /**
     * Check if MIDI rendering is available on this system.
     * Tests actual method invocation to verify module access is permitted.
     */
    public static boolean isAvailable() {
        if (audioSynthAvailable != null) {
            return audioSynthAvailable;
        }

        Synthesizer synth = null;
        AudioInputStream testStream = null;
        try {
            // First check if the class exists
            Class<?> audioSynthClass = Class.forName(AUDIO_SYNTH_CLASS);

            // Then check if the synthesizer is an instance of it
            synth = MidiSystem.getSynthesizer();
            if (!audioSynthClass.isInstance(synth)) {
                audioSynthAvailable = false;
                return false;
            }

            // Get the openStream method
            Method openStreamMethod = audioSynthClass.getMethod("openStream", AudioFormat.class, Map.class);

            // Actually try to invoke it - this is where IllegalAccessException would occur
            AudioFormat testFormat = new AudioFormat(44100, 16, 1, true, false);
            testStream = (AudioInputStream) openStreamMethod.invoke(synth, testFormat, null);

            // If we got here, access is permitted
            audioSynthAvailable = true;
            return true;

        } catch (Exception e) {
            // IllegalAccessException, InvocationTargetException, etc.
            audioSynthAvailable = false;
            return false;
        } finally {
            // Clean up test resources
            if (testStream != null) {
                try { testStream.close(); } catch (Exception ignored) {}
            }
            if (synth != null) {
                try { synth.close(); } catch (Exception ignored) {}
            }
        }
    }
}
